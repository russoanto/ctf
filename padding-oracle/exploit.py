from Crypto.Util.Padding import pad
from pwn import *

def xor(a: bytearray, b: bytearray) -> bytearray:

    assert len(a) == len(b)
    return bytearray([ x ^ y for x, y in zip(a, b)])

BLOCK_SIZE, IP, PORT = 16, "127.0.0.1", 1717
client = connect(IP, PORT)

#metto gli zero così quando faccio lo xor con il blocco cifrato modifico solo quello che c'è dopo l'uguale
inj = b"\x00\x00\x00\x00\x00I am a boss\x00\x00\x00\x00\x00\x00admin"
user, desc = b"\x00\x00\x00\x00\x00\x00exoar", b"\x00\x00\x00\x00\x00edopuzzatan"
my_token = bytearray.fromhex(desc.hex() + user.hex())
# print(f"[+] my_token: {my_token}")

try:

    client.recvuntil(b"> ")
    client.sendline(b"1")
    client.recvuntil(b"> ")
    client.sendline(b"exoar")
    client.recvuntil(b"> ")
    client.sendline(b"edopuzzatan")
    
    token = bytearray.fromhex(client.recvuntil(b"> ").decode().split("\n")[0].strip().split(":")[1].strip())
    print("token stock: ",token)
    iv, enc_token = token[:BLOCK_SIZE], token[BLOCK_SIZE:]
    inj, size = bytearray.fromhex(inj.hex()), len(inj[BLOCK_SIZE:])
    print("inj: ",inj)

    # IV
    new_iv = xor(xor(iv, inj[:BLOCK_SIZE]), my_token[:BLOCK_SIZE])

    # blocco 1
    block1 = enc_token[:BLOCK_SIZE]
    print("block1: ", block1)

    # blocco 2
    block2 = bytearray([ 16 for _ in range(BLOCK_SIZE) ])
    print("block2: ", block2)

    # blocco 3
    block3 = bytearray(BLOCK_SIZE)
    for i in range(BLOCK_SIZE):
        if i < size:
            block3[i] = block1[i] ^ inj[BLOCK_SIZE:][i] ^ my_token[BLOCK_SIZE:][i]
        else:
            block3[i] = block1[i] ^ block3[i]

    # blocco 4
    block4 = enc_token[BLOCK_SIZE:]

    for i in range(256):
        block2[0] = i
        client.sendline(b"2")
        client.recvuntil(b"> ")
        client.sendline((new_iv.hex() + block1.hex() + block2.hex() + block3.hex() + block4.hex()).encode())
        roba = client.recvuntil(b"> ").decode()
        if roba.find("UniTN") > -1:
            flag = roba.split("\n")[0]
            print(f"[+] flag: {flag}") 
            break
    # client.sendline(b"2")
    # client.recvuntil(b"> ")
    # client.sendline((new_iv.hex() + block1.hex() + block2.hex() + block3.hex() + block4.hex()).encode())
    # roba = client.recvuntil(b"> ").decode()
    # print(roba)
    # if roba.find("UniTN") > -1:
    #     flag = roba.split("\n")[0]
    #     print(f"[+] flag: {flag}") 

except Exception as err:
    print(f"[-] error msg: {err}")

client.sendline(b"3")
client.close()
